<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PetitBac Multijoueur</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 900px;
            width: 100%;
            padding: 40px;
            max-height: 90vh;
            overflow-y: auto;
        }

        h1 {
            color: #667eea;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .section {
            display: none;
        }

        .section.active {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
            margin: 10px 0;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .input-group {
            margin: 20px 0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 500;
        }

        input[type="text"],
        input[type="number"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus,
        input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .categories-list {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            min-height: 50px;
        }

        .category-item {
            background: white;
            padding: 10px 15px;
            border-radius: 6px;
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .category-item button {
            background: #dc3545;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            line-height: 1;
        }

        .room-code {
            background: #667eea;
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin: 20px 0;
        }

        .room-code h2 {
            font-size: 2em;
            letter-spacing: 5px;
        }

        .players-list {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .player-item {
            background: white;
            padding: 12px;
            border-radius: 6px;
            margin: 8px 0;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .player-status {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #28a745;
            margin-right: 10px;
        }

        .game-grid {
            margin: 20px 0;
        }

        .answer-row {
            display: grid;
            grid-template-columns: 200px 1fr;
            gap: 10px;
            margin: 10px 0;
        }

        .category-cell {
            background: #667eea;
            color: white;
            padding: 15px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            font-weight: 500;
        }

        .answer-input {
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
        }

        .letter-display {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            font-size: 4em;
            text-align: center;
            padding: 30px;
            border-radius: 15px;
            margin: 20px 0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .timer {
            font-size: 2.5em;
            text-align: center;
            color: #667eea;
            margin: 20px 0;
            font-weight: bold;
        }

        .timer.warning {
            color: #dc3545;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .controls {
            text-align: center;
            margin: 20px 0;
        }

        .stop-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            font-size: 1.5em;
            padding: 20px 50px;
        }

        /* Styles pour la validation */
        .validation-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
        }

        .validation-header {
            background: #667eea;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-weight: bold;
            font-size: 1.1em;
        }

        .validation-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            margin: 10px 0;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
        }

        .validation-row.validated {
            border-color: #28a745;
            background: #d4edda;
        }

        .validation-row.rejected {
            border-color: #dc3545;
            background: #f8d7da;
        }

        .answer-info {
            flex: 1;
        }

        .player-name-small {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .answer-text {
            font-size: 1.2em;
            color: #333;
        }

        .validation-buttons {
            display: flex;
            gap: 10px;
        }

        .validate-btn, .reject-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .validate-btn {
            background: #28a745;
            color: white;
        }

        .validate-btn:hover:not(:disabled) {
            background: #218838;
            transform: scale(1.05);
        }

        .reject-btn {
            background: #dc3545;
            color: white;
        }

        .reject-btn:hover:not(:disabled) {
            background: #c82333;
            transform: scale(1.05);
        }

        .validate-btn:disabled, .reject-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .validation-status {
            background: #fff3cd;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            font-weight: bold;
        }

        .validation-progress {
            background: #e9ecef;
            height: 30px;
            border-radius: 15px;
            margin: 20px 0;
            overflow: hidden;
        }

        .validation-progress-bar {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .results-grid {
            overflow-x: auto;
            margin: 20px 0;
        }

        .results-row {
            display: flex;
            min-width: 600px;
        }

        .results-cell {
            flex: 1;
            padding: 15px;
            border: 1px solid #e0e0e0;
            min-width: 150px;
        }

        .header-row .results-cell {
            background: #667eea;
            color: white;
            font-weight: bold;
        }

        .category-name {
            background: #f8f9fa;
            font-weight: 500;
        }

        .points-badge {
            background: #28a745;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            margin-left: 5px;
        }

        .invalid-badge {
            background: #dc3545;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            margin-left: 5px;
        }

        .player-score-summary {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .empty {
            color: #ccc;
            text-align: center;
        }

        #statusMessage {
            background: #fff3cd;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            text-align: center;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéÆ PetitBac Multijoueur</h1>

        <!-- Menu principal -->
        <div class="section active" id="menuSection">
            <button class="btn" id="btnShowCreate">Cr√©er une partie</button>
            <button class="btn btn-secondary" id="btnShowJoin">Rejoindre une partie</button>
        </div>

        <!-- Cr√©er une salle -->
        <div class="section" id="createRoomSection">
            <h2>Cr√©er une partie</h2>
            <div class="input-group">
                <label>Votre pseudo :</label>
                <input type="text" id="hostName" placeholder="Entrez votre pseudo">
            </div>
            <div class="input-group">
                <label>Dur√©e du timer (en secondes) :</label>
                <input type="number" id="timerDuration" value="60" min="30" max="300">
            </div>
            <div class="input-group">
                <label>Ajouter des cat√©gories :</label>
                <input type="text" id="categoryInput" placeholder="Ex: Pr√©nom, Animal, Ville...">
                <button class="btn" id="btnAddCategory">Ajouter</button>
            </div>
            <div class="categories-list" id="categoriesList"></div>
            <button class="btn" id="btnCreateRoom">Cr√©er la salle</button>
            <button class="btn btn-secondary" id="btnBackFromCreate">Retour</button>
        </div>

        <!-- Rejoindre une salle -->
        <div class="section" id="joinRoomSection">
            <h2>Rejoindre une partie</h2>
            <div class="input-group">
                <label>Votre pseudo :</label>
                <input type="text" id="playerName" placeholder="Entrez votre pseudo">
            </div>
            <div class="input-group">
                <label>Code de la salle :</label>
                <input type="text" id="joinRoomCode" placeholder="Ex: ABC123">
            </div>
            <button class="btn" id="btnJoinRoom">Rejoindre</button>
            <button class="btn btn-secondary" id="btnBackFromJoin">Retour</button>
        </div>

        <!-- Lobby -->
        <div class="section" id="lobbySection">
            <div class="room-code">
                <p>Code de la salle :</p>
                <h2 id="roomCode">------</h2>
                <p>Partagez ce code avec vos amis</p>
            </div>
            <h3>Joueurs connect√©s :</h3>
            <div class="players-list" id="playersList"></div>
            <button class="btn" id="btnStartGame">D√©marrer la partie</button>
            <button class="btn btn-secondary" id="btnLeaveRoom">Quitter la salle</button>
        </div>

        <!-- Jeu -->
        <div class="section" id="gameSection">
            <div class="letter-display">
                Lettre : <span id="letterDisplay"></span>
            </div>

            <div class="timer" id="timer">00:00</div>

            <div id="statusMessage"></div>

            <div class="game-grid" id="answersGrid"></div>

            <div class="controls">
                <button class="btn stop-btn" id="stopBtn" disabled>STOP !</button>
            </div>
        </div>

        <!-- Section Validation -->
        <div class="section" id="validationSection">
            <h2>‚úÖ Validation des r√©ponses</h2>
            <div class="validation-status" id="validationStatus">
                Validez ou refusez les r√©ponses des autres joueurs
            </div>
            
            <div class="validation-progress">
                <div class="validation-progress-bar" id="validationProgress" style="width: 0%;">0%</div>
            </div>

            <div id="validationGrid"></div>
        </div>

        <!-- Section R√©sultats -->
        <div class="section" id="resultsSection">
            <h2>üèÜ R√©sultats de la manche</h2>
            <p id="winnerMessage" style="text-align: center; font-size: 1.2em; margin: 20px 0;"></p>
            
            <h3>üìä Scores totaux</h3>
            <div id="scoresSummary"></div>

            <h3>üìã Toutes les r√©ponses</h3>
            <div class="results-grid" id="resultsGrid"></div>

            <button class="btn" id="btnNewRound">Nouvelle lettre</button>
            <button class="btn btn-secondary" id="btnEndGame">Terminer la partie</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, get, update, onValue, push, remove, onDisconnect } 
            from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        const firebaseConfig = {
            apiKey: "AIzaSyBdKGPyyyqh5g3bIMH3OoARpDEgdjKDhAY",
            authDomain: "petitbac-3f028.firebaseapp.com",
            databaseURL: "https://petitbac-3f028-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "petitbac-3f028",
            storageBucket: "petitbac-3f028.firebasestorage.app",
            messagingSenderId: "729978066",
            appId: "1:729978066:web:e45d6def9426d8b976090b"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        let currentRoomCode = null;
        let currentPlayerId = null;
        let currentPlayerName = null;
        let isHost = false;
        let categories = [];
        let timerInterval = null;
        let roomRef = null;
        let hasProcessedStop = false;

        function showSection(sectionId) {
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            const section = document.getElementById(sectionId);
            if (section) {
                section.classList.add('active');
            } else {
                console.error('Section non trouv√©e:', sectionId);
            }
        }

        function updateCategoriesDisplay() {
            const list = document.getElementById('categoriesList');
            list.innerHTML = categories.map((cat, i) => 
                `<div class="category-item">
                    <span>${cat}</span>
                    <button class="cat-remove-btn" data-index="${i}">√ó</button>
                </div>`
            ).join('');
            
            document.querySelectorAll('.cat-remove-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const index = parseInt(this.getAttribute('data-index'));
                    categories.splice(index, 1);
                    updateCategoriesDisplay();
                });
            });
        }

        function getRandomLetter() {
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            return letters[Math.floor(Math.random() * letters.length)];
        }

        function updatePlayersList(players) {
            const playersList = document.getElementById('playersList');
            playersList.innerHTML = Object.values(players || {}).map(player => `
                <div class="player-item">
                    <div class="player-status"></div>
                    <span>${player.name}${player.isHost ? ' (H√¥te)' : ''}</span>
                </div>
            `).join('');
        }

        async function saveMyAnswers() {
            try {
                const myAnswers = [];
                categories.forEach((cat, index) => {
                    const input = document.getElementById(`answer-${index}`);
                    myAnswers.push(input ? input.value.trim() : '');
                });
                
                await set(ref(database, `rooms/${currentRoomCode}/answers/${currentPlayerId}`), myAnswers);
                console.log('‚úì R√©ponses sauvegard√©es:', myAnswers);
            } catch (error) {
                console.error('Erreur lors de la sauvegarde des r√©ponses:', error);
            }
        }

        function startTimer(duration) {
            clearInterval(timerInterval);
            let timeLeft = duration;
            const timerDisplay = document.getElementById('timer');

            timerInterval = setInterval(async () => {
                timeLeft--;
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                if (timeLeft <= 10) {
                    timerDisplay.classList.add('warning');
                } else {
                    timerDisplay.classList.remove('warning');
                }

                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    document.getElementById('stopBtn').disabled = true;
                    
                    await saveMyAnswers();
                    
                    if (isHost && !hasProcessedStop) {
                        hasProcessedStop = true;
                        await update(ref(database, `rooms/${currentRoomCode}/gameState`), {
                            stoppedBy: 'timer',
                            stoppedByName: 'Timer'
                        });
                        await stopRound('Timer');
                    }
                }
            }, 1000);
        }

        function startGamePlay(roomData) {
            showSection('gameSection');
            categories = roomData.categories;
            
            const grid = document.getElementById('answersGrid');
            grid.innerHTML = categories.map((cat, index) => `
                <div class="answer-row">
                    <div class="category-cell">${cat}</div>
                    <input type="text" 
                           class="answer-input" 
                           id="answer-${index}"
                           placeholder="Votre r√©ponse...">
                </div>
            `).join('');

            document.getElementById('letterDisplay').textContent = roomData.gameState.currentLetter;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('statusMessage').style.display = 'none';
            
            hasProcessedStop = false;
            
            startTimer(roomData.timerDuration);
        }

        async function stopRound(stoppedByName) {
            try {
                console.log('>>> stopRound appel√© par:', stoppedByName);
                clearInterval(timerInterval);
                
                await update(ref(database, `rooms/${currentRoomCode}/gameState`), {
                    roundActive: false
                });

                await new Promise(resolve => setTimeout(resolve, 1500));

                // Passer √† la phase de validation au lieu des r√©sultats
                await startValidationPhase(stoppedByName);
            } catch (error) {
                console.error('Erreur dans stopRound:', error);
            }
        }

        async function startValidationPhase(stoppedByName) {
            await update(roomRef, {
                status: 'validation',
                stoppedByName: stoppedByName,
                validations: {}
            });
        }

        function showValidationPhase(roomData) {
            showSection('validationSection');
            
            const players = roomData.players;
            const answers = roomData.answers || {};
            const currentLetter = roomData.gameState.currentLetter;
            const validations = roomData.validations || {};
            const myValidations = validations[currentPlayerId] || {};

            let html = '';

            categories.forEach((cat, catIndex) => {
                html += `<div class="validation-card">
                    <div class="validation-header">${cat}</div>`;

                Object.entries(answers).forEach(([playerId, playerAnswers]) => {
                    if (playerId === currentPlayerId) return; // Ne pas valider ses propres r√©ponses

                    const answer = playerAnswers[catIndex] || '';
                    const player = players[playerId];
                    const validationKey = `${catIndex}_${playerId}`;
                    const currentValidation = myValidations[validationKey];

                    if (answer.trim()) {
                        const validClass = currentValidation === true ? 'validated' : 
                                         currentValidation === false ? 'rejected' : '';

                        html += `
                            <div class="validation-row ${validClass}">
                                <div class="answer-info">
                                    <div class="player-name-small">${player.name}</div>
                                    <div class="answer-text">${answer}</div>
                                </div>
                                <div class="validation-buttons">
                                    <button class="validate-btn" 
                                            onclick="validateAnswer(${catIndex}, '${playerId}', true)"
                                            ${currentValidation === true ? 'disabled' : ''}>
                                        ‚úì Valider
                                    </button>
                                    <button class="reject-btn" 
                                            onclick="validateAnswer(${catIndex}, '${playerId}', false)"
                                            ${currentValidation === false ? 'disabled' : ''}>
                                        ‚úó Refuser
                                    </button>
                                </div>
                            </div>
                        `;
                    }
                });

                html += `</div>`;
            });

            document.getElementById('validationGrid').innerHTML = html;

            // Mettre √† jour la progression
            updateValidationProgress(roomData);
        }

        function updateValidationProgress(roomData) {
            const players = roomData.players;
            const validations = roomData.validations || {};
            const playerCount = Object.keys(players).length;
            const validatedCount = Object.keys(validations).length;

            const progress = (validatedCount / playerCount) * 100;
            const progressBar = document.getElementById('validationProgress');
            progressBar.style.width = progress + '%';
            progressBar.textContent = `${validatedCount}/${playerCount} joueurs ont vot√©`;

            const statusDiv = document.getElementById('validationStatus');
            if (validatedCount === playerCount) {
                statusDiv.textContent = '‚úÖ Tous les joueurs ont valid√© ! Calcul des r√©sultats...';
                statusDiv.style.background = '#d4edda';
                statusDiv.style.color = '#155724';

                // Si je suis l'h√¥te, calculer les r√©sultats
                if (isHost) {
                    setTimeout(() => {
                        calculateAndShowResults(roomData.stoppedByName);
                    }, 2000);
                }
            } else {
                statusDiv.textContent = `En attente de ${playerCount - validatedCount} joueur(s)...`;
            }
        }

        window.validateAnswer = async function(catIndex, playerId, isValid) {
            try {
                const validationKey = `${catIndex}_${playerId}`;
                
                await update(ref(database, `rooms/${currentRoomCode}/validations/${currentPlayerId}`), {
                    [validationKey]: isValid
                });

                console.log('‚úì Validation enregistr√©e:', validationKey, isValid);
            } catch (error) {
                console.error('Erreur validation:', error);
            }
        };

        async function calculateAndShowResults(stoppedByName) {
            const roomSnapshot = await get(roomRef);
            const roomData = roomSnapshot.val();
            const players = roomData.players;
            const answers = roomData.answers || {};
            const currentLetter = roomData.gameState.currentLetter;
            const totalScores = roomData.scores || {};
            const validations = roomData.validations || {};

            const roundScores = {};
            Object.keys(players).forEach(pid => {
                roundScores[pid] = 0;
            });

            const answerDetails = {};

            categories.forEach((cat, catIndex) => {
                const categoryAnswers = {};
                
                // Collecter les r√©ponses valides (commencent par la bonne lettre ET valid√©es par les autres)
                Object.entries(answers).forEach(([playerId, playerAnswers]) => {
                    const answer = (playerAnswers[catIndex] || '').toUpperCase();
                    
                    if (answer && answer[0] === currentLetter) {
                        // V√©rifier les validations des autres joueurs
                        const validationKey = `${catIndex}_${playerId}`;
                        let validCount = 0;
                        let totalVotes = 0;

                        Object.entries(validations).forEach(([voterId, voterValidations]) => {
                            if (voterId !== playerId && voterValidations[validationKey] !== undefined) {
                                totalVotes++;
                                if (voterValidations[validationKey] === true) {
                                    validCount++;
                                }
                            }
                        });

                        // L'r√©ponse est accept√©e si majorit√© de votes positifs
                        const isAccepted = totalVotes === 0 || (validCount > totalVotes / 2);
                        
                        if (isAccepted) {
                            categoryAnswers[playerId] = answer;
                        }

                        // Stocker les infos de validation pour l'affichage
                        if (!answerDetails[cat]) answerDetails[cat] = {};
                        answerDetails[cat][playerId] = {
                            answer: answer,
                            points: 0,
                            validated: isAccepted,
                            validCount: validCount,
                            totalVotes: totalVotes
                        };
                    }
                });

                // Calculer les points pour les r√©ponses valid√©es
                const answerCounts = {};
                Object.values(categoryAnswers).forEach(answer => {
                    if (answer) {
                        answerCounts[answer] = (answerCounts[answer] || 0) + 1;
                    }
                });

                Object.entries(categoryAnswers).forEach(([playerId, answer]) => {
                    if (answer) {
                        const points = answerCounts[answer] === 1 ? 2 : 1;
                        roundScores[playerId] += points;
                        
                        if (answerDetails[cat] && answerDetails[cat][playerId]) {
                            answerDetails[cat][playerId].points = points;
                        }
                    }
                });
            });

            const updatedTotalScores = {};
            Object.keys(players).forEach(pid => {
                updatedTotalScores[pid] = (totalScores[pid] || 0) + (roundScores[pid] || 0);
            });

            await update(roomRef, {
                status: 'results',
                roundScores: roundScores,
                scores: updatedTotalScores,
                answerDetails: answerDetails,
                stoppedByName: stoppedByName
            });
        }

        function showResultsFromData(roomData) {
            showSection('resultsSection');

            const players = roomData.players;
            const scores = roomData.scores || {};
            const roundScores = roomData.roundScores || {};
            const answerDetails = roomData.answerDetails || {};
            const stoppedByName = roomData.stoppedByName;

            if (stoppedByName) {
                document.getElementById('winnerMessage').textContent = 
                    `${stoppedByName} a appuy√© sur STOP en premier !`;
            }

            const sortedPlayers = Object.entries(players)
                .map(([id, player]) => ({ 
                    id, 
                    ...player, 
                    totalScore: scores[id] || 0,
                    roundScore: roundScores[id] || 0
                }))
                .sort((a, b) => b.totalScore - a.totalScore);

            const scoresHTML = sortedPlayers.map((player, index) => `
                <div class="player-score-summary">
                    <span>${index + 1}. ${player.name}</span>
                    <span>+${player.roundScore} pts cette manche | Total: ${player.totalScore} pts</span>
                </div>
            `).join('');

            document.getElementById('scoresSummary').innerHTML = scoresHTML;

            const resultsGrid = document.getElementById('resultsGrid');
            
            const headerRow = `
                <div class="results-row header-row">
                    <div class="results-cell">Cat√©gorie</div>
                    ${sortedPlayers.map(p => `<div class="results-cell">${p.name}</div>`).join('')}
                </div>
            `;

            const categoryRows = categories.map(cat => {
                const categoryData = answerDetails[cat] || {};
                return `
                    <div class="results-row">
                        <div class="results-cell category-name">${cat}</div>
                        ${sortedPlayers.map(p => {
                            const data = categoryData[p.id];
                            if (data && data.answer) {
                                if (data.validated) {
                                    return `<div class="results-cell">
                                        ${data.answer}
                                        <span class="points-badge">${data.points} pt${data.points > 1 ? 's' : ''}</span>
                                    </div>`;
                                } else {
                                    return `<div class="results-cell">
                                        <strike>${data.answer}</strike>
                                        <span class="invalid-badge">Refus√©e</span>
                                    </div>`;
                                }
                            }
                            return `<div class="results-cell empty">-</div>`;
                        }).join('')}
                    </div>
                `;
            }).join('');

            resultsGrid.innerHTML = headerRow + categoryRows;

            document.getElementById('btnNewRound').style.display = isHost ? 'block' : 'none';
        }

        function updateGameState(roomData) {
            if (roomData.gameState?.currentLetter) {
                document.getElementById('letterDisplay').textContent = roomData.gameState.currentLetter;
            }

            if (roomData.gameState?.stoppedBy && 
                roomData.gameState?.stoppedByName && 
                isHost && 
                !hasProcessedStop &&
                roomData.gameState.roundActive) {
                
                console.log('>>> H√¥te d√©tecte un STOP de:', roomData.gameState.stoppedByName);
                hasProcessedStop = true;
                clearInterval(timerInterval);
                
                const statusMsg = document.getElementById('statusMessage');
                statusMsg.textContent = `${roomData.gameState.stoppedByName} a appuy√© sur STOP ! Calcul des r√©sultats...`;
                statusMsg.style.display = 'block';
                
                document.getElementById('stopBtn').disabled = true;
                
                setTimeout(async () => {
                    await stopRound(roomData.gameState.stoppedByName);
                }, 500);
            }
            else if (roomData.gameState?.stoppedBy && 
                     roomData.gameState?.stoppedByName && 
                     !hasProcessedStop) {
                
                console.log('>>> Joueur voit le STOP de:', roomData.gameState.stoppedByName);
                hasProcessedStop = true;
                clearInterval(timerInterval);
                
                const statusMsg = document.getElementById('statusMessage');
                statusMsg.textContent = `${roomData.gameState.stoppedByName} a appuy√© sur STOP ! En attente des r√©sultats...`;
                statusMsg.style.display = 'block';
                
                document.getElementById('stopBtn').disabled = true;
            }
        }

        function setupRoomListener() {
            onValue(roomRef, (snapshot) => {
                const roomData = snapshot.val();
                
                if (!roomData) {
                    alert('La salle a √©t√© ferm√©e');
                    showSection('menuSection');
                    return;
                }

                updatePlayersList(roomData.players);

                if (roomData.status === 'playing' && !document.getElementById('gameSection').classList.contains('active')) {
                    startGamePlay(roomData);
                }

                if (roomData.status === 'playing') {
                    updateGameState(roomData);
                }

                if (roomData.status === 'validation') {
                    showValidationPhase(roomData);
                }

                if (roomData.status === 'results') {
                    showResultsFromData(roomData);
                }
            });
        }

        document.addEventListener('DOMContentLoaded', function() {
            console.log('‚úì DOM charg√©, configuration des event listeners...');

            document.getElementById('btnShowCreate').addEventListener('click', () => {
                showSection('createRoomSection');
            });

            document.getElementById('btnShowJoin').addEventListener('click', () => {
                showSection('joinRoomSection');
            });

            document.getElementById('btnAddCategory').addEventListener('click', () => {
                const input = document.getElementById('categoryInput');
                const cat = input.value.trim();
                if (cat) {
                    categories.push(cat);
                    updateCategoriesDisplay();
                    input.value = '';
                }
            });

            document.getElementById('categoryInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('btnAddCategory').click();
                }
            });

            document.getElementById('btnCreateRoom').addEventListener('click', async () => {
                const playerName = document.getElementById('hostName').value.trim();
                const timerDuration = parseInt(document.getElementById('timerDuration').value);
                
                if (!playerName || categories.length === 0) {
                    alert('Veuillez remplir tous les champs et ajouter au moins une cat√©gorie');
                    return;
                }

                currentPlayerName = playerName;
                currentPlayerId = Date.now().toString();
                isHost = true;

                const roomCode = Math.random().toString(36).substring(2, 8).toUpperCase();
                currentRoomCode = roomCode;
                roomRef = ref(database, `rooms/${roomCode}`);

                const roomData = {
                    host: currentPlayerId,
                    status: 'waiting',
                    categories: categories,
                    timerDuration: timerDuration,
                    players: {
                        [currentPlayerId]: {
                            name: playerName,
                            isHost: true
                        }
                    },
                    scores: {},
                    gameState: {
                        currentLetter: '',
                        roundActive: false,
                        stoppedBy: null,
                        stoppedByName: null
                    }
                };

                await set(roomRef, roomData);
                onDisconnect(ref(database, `rooms/${roomCode}/players/${currentPlayerId}`)).remove();
                
                document.getElementById('roomCode').textContent = roomCode;
                showSection('lobbySection');
                setupRoomListener();
            });

            document.getElementById('btnBackFromCreate').addEventListener('click', () => {
                showSection('menuSection');
            });

            document.getElementById('btnJoinRoom').addEventListener('click', async () => {
                const playerName = document.getElementById('playerName').value.trim();
                const roomCode = document.getElementById('joinRoomCode').value.trim().toUpperCase();

                if (!playerName || !roomCode) {
                    alert('Veuillez remplir tous les champs');
                    return;
                }

                currentRoomCode = roomCode;
                currentPlayerName = playerName;
                currentPlayerId = Date.now().toString();
                roomRef = ref(database, `rooms/${roomCode}`);

                const snapshot = await get(roomRef);
                if (!snapshot.exists()) {
                    alert('Cette salle n\'existe pas');
                    return;
                }

                const roomData = snapshot.val();
                if (roomData.status !== 'waiting') {
                    alert('La partie a d√©j√† commenc√©');
                    return;
                }

                await update(ref(database, `rooms/${roomCode}/players/${currentPlayerId}`), {
                    name: playerName,
                    isHost: false
                });

                onDisconnect(ref(database, `rooms/${roomCode}/players/${currentPlayerId}`)).remove();

                document.getElementById('roomCode').textContent = roomCode;
                showSection('lobbySection');
                setupRoomListener();
            });

            document.getElementById('btnBackFromJoin').addEventListener('click', () => {
                showSection('menuSection');
            });

            document.getElementById('btnStartGame').addEventListener('click', async () => {
                if (!isHost) return;

                await update(roomRef, {
                    status: 'playing',
                    gameState: {
                        currentLetter: getRandomLetter(),
                        roundActive: true,
                        stoppedBy: null,
                        stoppedByName: null
                    },
                    answers: {},
                    roundScores: {}
                });
            });

            document.getElementById('btnLeaveRoom').addEventListener('click', async () => {
                if (currentRoomCode && currentPlayerId) {
                    await remove(ref(database, `rooms/${currentRoomCode}/players/${currentPlayerId}`));
                    
                    if (isHost) {
                        await remove(roomRef);
                    }
                }
                
                clearInterval(timerInterval);
                currentRoomCode = null;
                currentPlayerId = null;
                isHost = false;
                categories = [];
                
                showSection('menuSection');
            });

            document.getElementById('stopBtn').addEventListener('click', async () => {
                console.log('>>> BOUTON STOP CLIQU√â <<<');
                
                const btn = document.getElementById('stopBtn');
                if (btn.disabled) {
                    console.log('Bouton d√©j√† d√©sactiv√©');
                    return;
                }
                
                btn.disabled = true;
                
                try {
                    console.log('1. Sauvegarde des r√©ponses...');
                    await saveMyAnswers();
                    
                    console.log('2. R√©cup√©ration de l\'√©tat de la room...');
                    const roomSnapshot = await get(roomRef);
                    const roomData = roomSnapshot.val();
                    
                    if (roomData.gameState.stoppedBy) {
                        console.log('Quelqu\'un a d√©j√† stopp√©');
                        return;
                    }

                    console.log('3. Mise √† jour de Firebase avec stoppedBy...');
                    await update(ref(database, `rooms/${currentRoomCode}/gameState`), {
                        stoppedBy: currentPlayerId,
                        stoppedByName: currentPlayerName
                    });

                    console.log('‚úì STOP enregistr√© pour:', currentPlayerName);

                    if (isHost && !hasProcessedStop) {
                        console.log('4. Je suis l\'h√¥te, d√©clenchement de stopRound...');
                        hasProcessedStop = true;
                        clearInterval(timerInterval);
                        await stopRound(currentPlayerName);
                    } else {
                        console.log('4. Je ne suis pas l\'h√¥te, attente de l\'h√¥te...');
                    }
                } catch (error) {
                    console.error('‚ùå Erreur dans le STOP:', error);
                    btn.disabled = false;
                }
            });

            document.getElementById('btnNewRound').addEventListener('click', async () => {
                if (!isHost) return;

                hasProcessedStop = false;

                await update(roomRef, {
                    status: 'playing',
                    gameState: {
                        currentLetter: getRandomLetter(),
                        roundActive: true,
                        stoppedBy: null,
                        stoppedByName: null
                    },
                    answers: {},
                    roundScores: {},
                    answerDetails: {},
                    validations: {},
                    stoppedByName: null
                });
            });

            document.getElementById('btnEndGame').addEventListener('click', async () => {
                if (!isHost) return;
                
                if (confirm('Voulez-vous vraiment terminer la partie pour tous les joueurs ?')) {
                    await remove(roomRef);
                    showSection('menuSection');
                }
            });

            console.log('‚úì Tous les event listeners configur√©s');
        });
    </script>
</body>
</html>
